# номер посылки 69660438
'''
-- ПРИНЦИП РАБОТЫ --
Чтобы проверить тот факт что от одного города до другого можно добраться только по дорогам 
одного типа мы используем 2 факта:
- проехать можно всегда от меньшего города к большему.
- существует 2 вида дорог.
по условию они идут от вершины с 
тоесть если положить, что дороги одного типа ведут от меньшего к большему, а дороги другого 
типа ведут наоборот, то нам достаточно проверить есть ли циклы в таком ориентированном графе,
если циклов нет, значит от одного города до другого можно добраться только по одному виду дорог,
иначе нет. 
UPDATE: Евгений ваш пример с 1->3=>2->4=>1 даст цикл в любом случае так как по условию каждая вершина
графа связана с каждой вершиной и если есть хотя бы одна тройка где есть цикл то ответ будет NO не оптимальный.
В примере 1->3=>2->4=>1 как бы мы не соединили вершины 3 и 4 мы получим цикл 1 3 4 1 или 3 2 4 3.
UPDATE2: может быть так?
Каждая вершина связана с любой другой дорогой одного вида.
возможные варианты связей 3-х вершин:

НЕ ОПТИМАЛЬНЫЙ (при замене => на обратный, появляется цикл):
1->2
2->3
1=>3

ОПТИМАЛЬНЫЙ (при замене => на обратный цикл не получается):
1->2
1->3
2->3

1->2
1->3
2=>3

так как любые 3 вершины связаны 3мя дугами от меньшего к большему, если путь не оптимальный 
то найдётся такой цикл из 3х вершин где появится цикл при смене одного вида дорог на дорогу 
противоположного направления.

Будем считать что дороги от меньшего к большему записаны символом R
а дороги от большего к меньшему записаны символом B.
Напишем типичный алгоритм DFS на стэке с окраской в серый и чёрный.
Если текущая проверяемая вершина V то при обработке рёбер делаем цикл c индексом V2 от [0, N)
Если V < V2 то мы движемся от меньшей вершины к большей и мы проверяем если текущее ребро "R".
Если V > V2 то мы движемся от большей вершины к меньшей и мы проверяем если текущее ребро "B".
Если при проверке следующих смежных вершин мы видим что вершина уже окрашена в серый цвет, 
это означет что мы нашли цикл и что от города до города можно добраться по дорогам разного типа.
сразу возвращаем "NO", иначе если мы обошли весь граф и не нашли циклов возвращаем "YES"

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В нашем случае граф плотный и кол-во рёбер равняется кол-ву вершин и для каждой вершины
в нашем алгоритме мы перебираем все рёбра. Так как мы проходим каждую вершину один раз
то в худшем случае наша производительность будет равняться O(V^2) где V-кол-во вершин в графе.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Так как используется матрица смежности сам граф занимает O(V^2) памяти при загруке в память.
Дополнительная память затрачиваемая при работе алгоритма:
- Stack O(V) в котором мы храним следующие индексы вершин при обходе DFS.
- Хэш таблицу color O(V) в которой мы записываем цвета вершин.
размеры обоих структур O(V) где V кол-во вершин. Суммарная пространственная сложность O(V)
UPDATE: Евгений для хранения графа нужно O(V^2) памяти так как каждая вершина связана с каждой вершиной и мы храним матрицу
смежности, что занимает квадратичную память, но для работы алгоритма жужно O(V) дополнительной памяти под стэк и хэш таблицу
цветов. Или не верно? Всегда немного confused какую память тут нужно указывать суммарную с матрицей или только дополнительную
для работы алгоритма. Наверное суммарную так как возможно можно сделать алгоритм чтобы не загружать матрицу смежности а 
использовать меньше квадратичной памяти на этапе чтения данных. Поэтому наверное этот алгоритм тратит суммарно O(V^2) памяти
'''

n = int(input())
mat = []
for i in range(n-1):
  mat.append(input())

# 1, 1
def getEdge(n, m):
  global mat
  return mat[n-1][m-2-(n-1)]

def DFS(s, n, color):
  global mat
  st = [s]

  # DFS
  while len(st) > 0:

    v = st.pop()
    # if white
    if color.get(v, 0) == 0:
      # color Grey
      color[v] = 1
      st.append(v)

      # print('ver', v)
      # go through edges
      for v2 in range(n):
        if v < v2:
          # to speedup
          #if getEdge(v, v2) == "R":
          if mat[v][v2-1-v] == "R":
            c = color.get(v2, 0)
            if c == 0:
              st.append(v2)
            elif c == 1: # we found a cycle
              return "NO"
        elif v2 < v:
          # to speedup
          #if getEdge(v2, v) == "B":
          if mat[v2][v-1-v2] == "B":
            c = color.get(v2, 0)
            if c == 0:
              st.append(v2)
            elif c == 1: # we found a cycle
              return "NO"
    # if grey
    elif color[v] == 1:
      # to black
      color[v] = 2

  return "YES"


def solution(n, mat):
  color = {}

  # go through vertexes
  for s in range(n):
    # print('== dfs',s)
    if color.get(s, 0)==0:
      # call DFS
      if DFS(s, n, color) == "NO":
        return "NO"

  return "YES"

print(solution(n, mat))