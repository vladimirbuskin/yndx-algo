# посылка 68933537
import sys

'''
-- ПРИНЦИП РАБОТЫ --
Я реализовал broken_search c помощью двух методов
find_shift и bisect_left ниже описываю как они работают.

-- find_shift - необходим для поиска места где левый элемент является меньше правого. 
тоесть поиска сдвига который надо сделать влево чтобы получить нормально отсортированный массив.
Например для массива значение сдвига 3.

[4 5 6 1 2 3]

если все элементы сдвинуть влево на 3, то получим нормально отсортированный массив

[1 2 3 4 5 6]

метод работает по методу двоичного поиска.
в двоичном поиске удобно работать с полуинтервалом [l,r) где элемент с индексом r не принадлежит интервалу.
базовый случай рекурсии когда

r - l <= 1

тоесть когда остался только один элемент в нашем полуинтервале [l,r).
мы возващаем l+1 так как нам нужен первый правильный элемент (минимальный), плюс для защиты от переполнения
берём это по модулю длины массива.

l+1 % len(ar)

В теле рекурсии, ищем индекс среднего элемента m.
m = l+(r-l)//2
если значение в левой части интервала ar[l] < ar[m] это значит что место сдвига массива находится на этом интервале
поэтому делаем рекурсивный вызов для него, иначе делаем рекурсивный вызов для другой части массива.

--------------------
bisect_left это практически обычный бинарный поиск элемента, но так как наш массив является "сломанным", 
мы дополнительно передаём в него значение сдвига shift которое поможет нам вычислить "сломанные" индексы.
функция принимает значения [l,r) являющиеся границами нашего полуинтервала, изначально они

[0, len(ar))

внутри функции мы вычисляем sl (абревиатура shifted left)

sl = (l + shift) % len(nums)

вычисляем путём прибавления сдвига и берём по модулю длины массива чтобы индекс перенёсся в начало массива при переполнении, так как 
наш массив как мы является закольцованным.
таким же способом вычисляется sm (абревиатура shifted middle)

sm = (m + shift) % len(nums)

остальная часть алгоритма просто binary search поиск без дубликатов, поэтому при нахождении нужного элемента, сразу возвращаем его индекс.

Само решение функция broken_search делится на два вызова, вначале находим сдвиг, затем делаем бинарный поиск с переданным значением сдвига.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
временная сложность каждой функции find_shift и bisect_left является log(N). так как глубина дерева из N элементов является Log(N)
итого log(N) + Log(N) => 2Log(N) => Log(N) так как константы отбрасываются.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
дополнительная пространственная сложность каждой функции является log(N) для сохранения рекурсивных вызовов.
кроме стэка рекурсии затраты на память O(1). поэтому итоговая дополнительная пространственная сложность алгоритма
Log(N), суммарная же пространственная сложность вместе с самим массивом O(N + Log(N)) => O(N)
'''

def find_shift(ar, l, r):
  if r - l <= 1:
    return (l + 1) % len(ar)
  m = l + (r-l) // 2
  if ar[l] > ar[m]:
    return find_shift(ar, l, m)
  else:
    return find_shift(ar, m, r)

def bisect_left(nums, l, r, target, shift):
  sl = (l + shift) % len(nums)

  if r - l <= 1:
    if nums[sl] == target:
      return sl
    else:
      return -1

  m = (l + r) // 2
  sm = (m + shift) % len(nums)

  # found
  if target == nums[sm]:
    return sm
  # [l, m)
  elif target < nums[sm]:
    return bisect_left(nums, l, m, target, shift)
  # [m, r)
  else:
    return bisect_left(nums, m + 1, r, target, shift)

def broken_search(nums, target) -> int:
  shift = find_shift(nums, 0, len(nums))
  return bisect_left(nums, 0, len(nums), target, shift)

# def test():
#     arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
#     print(broken_search(arr, 1))

# n = int(input())
# target = int(input())
# nums = [int(i) for i in input().split(" ")]
# print(broken_search(nums, target))

