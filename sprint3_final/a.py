# посылка рекурсивная 68933537
# посылка итеративная 68967380
import sys

'''
-- ПРИНЦИП РАБОТЫ --
Я реализовал broken_search c помощью двух методов
find_shift и bisect_left ниже описываю как они работают.

-- find_shift - необходим для поиска места где левый элемент является меньше правого. 
тоесть поиска сдвига который надо сделать влево чтобы получить нормально отсортированный массив.
Например для массива значение сдвига 3.

[4 5 6 1 2 3]

если все элементы сдвинуть влево на 3, то получим нормально отсортированный массив

[1 2 3 4 5 6]

метод работает по методу двоичного поиска.
в двоичном поиске удобно работать с полуинтервалом [l,r) где элемент с индексом r не принадлежит интервалу.
базовый случай рекурсии когда

r - l <= 1

тоесть когда остался только один элемент в нашем полуинтервале [l,r).
мы возващаем l+1 так как нам нужен первый правильный элемент (минимальный), плюс для защиты от переполнения
берём это по модулю длины массива.

l+1 % len(ar)

В теле рекурсии, ищем индекс среднего элемента m.
m = l+(r-l)//2
если значение в левой части интервала ar[l] < ar[m] это значит что место сдвига массива находится на этом интервале
поэтому делаем рекурсивный вызов для него, иначе делаем рекурсивный вызов для другой части массива.

--------------------
bisect_left это практически обычный бинарный поиск элемента, но так как наш массив является "сломанным", 
мы дополнительно передаём в него значение сдвига shift которое поможет нам вычислить "сломанные" индексы.
функция принимает значения [l,r) являющиеся границами нашего полуинтервала, изначально они

[0, len(ar))

внутри функции мы вычисляем sl (абревиатура shifted left)

sl = (l + shift) % len(nums)

вычисляем путём прибавления сдвига и берём по модулю длины массива чтобы индекс перенёсся в начало массива при переполнении, так как 
наш массив как мы является закольцованным.
таким же способом вычисляется sm (абревиатура shifted middle)

sm = (m + shift) % len(nums)

остальная часть алгоритма просто binary search поиск без дубликатов, поэтому при нахождении нужного элемента, сразу возвращаем его индекс.

Само решение функция broken_search делится на два вызова, вначале находим сдвиг, затем делаем бинарный поиск с переданным значением сдвига.

-- ========== UPDATES =========== --
я оставил обе реализации на память, преобразовать рекурсивный метод в итеративный действительно оказалось не сложно для данного варианта, я полагаю
помогла теория, глубокое понимание базового случая рекурсии и тела рекурсии. 
Где условие базового случая рекурсии перешло в условие цикла.
Но не сложно потому как присутствует лишь один рекурсивный вызов, в алгоритмаз с несколькими вызовами пришлось бы по видимому использовать стэк
что имело бы ту же самую пространственную сложность как и рекурсивный метод, но рекурсивный короче и понятней.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
временная сложность каждой функции find_shift и bisect_left является log(N). так как каждый раз половина массива отбрасывается.
итого log(N) + Log(N) => 2Log(N) => Log(N) так как константы отбрасываются.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
после того как я убрал рекурсию дополнительная пространственная сложность работы каждой функции составляет O(1).
Суммарная пространственная сложность вместе с самим массивом O(N) + O(1) => O(N)
'''

def find_shift_recursive(ar, l, r):
  if r - l <= 1:
    return (l + 1) % len(ar)
  m = l + (r-l) // 2
  if ar[l] > ar[m]:
    return find_shift(ar, l, m)
  else:
    return find_shift(ar, m, r)

def find_shift_iterative(ar, l, r):
  while not r - l <= 1:
    m = l + (r-l) // 2
    if ar[l] > ar[m]:
      r = m
    else:
      l = m
  return (l + 1) % len(ar)

def bisect_left_recursive(nums, l, r, target, shift):
  sl = (l + shift) % len(nums)

  if r - l <= 1:
    if nums[sl] == target:
      return sl
    else:
      return -1

  m = (l + r) // 2
  sm = (m + shift) % len(nums)

  # found
  if target == nums[sm]:
    return sm
  # [l, m)
  elif target < nums[sm]:
    return bisect_left_recursive(nums, l, m, target, shift)
  # [m, r)
  else:
    return bisect_left_recursive(nums, m + 1, r, target, shift)

def bisect_left_iterative(nums, l, r, target, shift):
  # body of recursion
  while not r - l <= 1:
    sl = (l + shift) % len(nums)
    m = (l + r) // 2
    sm = (m + shift) % len(nums)

    # found
    if target == nums[sm]:
      return sm
    # [l, m)
    elif target < nums[sm]:
      r = m
    # [m, r)
    else:
      l = m + 1

  # after
  if r - l <= 1:
    sl = (l + shift) % len(nums)
    if nums[sl] == target:
      return sl
    else:
      return -1

def broken_search(nums, target) -> int:
  shift = find_shift_iterative(nums, 0, len(nums))
  return bisect_left_iterative(nums, 0, len(nums), target, shift)

# def test():
#     arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
#     print(broken_search(arr, 1))

# n = int(input())
# target = int(input())
# nums = [int(i) for i in input().split(" ")]
# print(broken_search(nums, target))

