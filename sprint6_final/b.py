# номер посылки 69660438
'''
-- ПРИНЦИП РАБОТЫ --
Чтобы проверить тот факт что от одного города до другого можно добраться только по дорогам 
одного типа мы используем 2 факта:
- проехать можно всегда от меньшего города к большему.
- существует 2 вида дорог.
тоесть если положить, что дороги одного типа ведут от меньшего к большему, а дороги другого 
типа ведут наоборот, до нам достаточно проверить есть ли циклы в таком ориентированном графе,
если циклов нет, значит от одного города до другого можно добраться только по одному виду дорог,
иначе нет.

Будем считать что дороги от меньшего к большему записаны символом R
а дороги от большего к меньшему записаны символом B.
Напишем типичный алгоритм DFS на стэке с окраской в серый и чёрный.
Если текущая проверяемая вершина V то при обработке рёбер делаем цикл c индексом V2 от [0, N)
Если V < V2 то мы движемся от меньшей вершины к большей и мы проверяем если текущее ребро "R".
Если V > V2 то мы движемся от большей вершины к меньшей и мы проверяем если текущее ребро "B".
Если при проверке следующих смежных вершин мы видим что вершина уже окрашена в серый цвет, 
это означет что мы нашли цикл и что от города до города можно добраться по дорогам разного типа.
сразу возвращаем "NO", иначе если мы обошли весь граф и не нашли циклов возвращаем "YES"

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В нашем случае граф плотный и кол-во рёбер равняется кол-ву вершин и для каждой вершины
в нашем алгоритме мы перебираем все рёбра. Так как мы проходим каждую вершину один раз
то в худшем случае наша производительность будет равняться O(V^2) где V-кол-во вершин в графе.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Так как используется матрица смежности сам граф занимает O(V^2) памяти при загруке в память.
Дополнительная память затрачиваемая при работе алгоритма:
- Stack O(V) в котором мы храним следующие индексы вершин при обходе DFS.
- Хэш таблицу color O(V) в которой мы записываем цвета вершин.
размеры обоих структур O(V) где V кол-во вершин. Суммарная пространственная сложность O(V)
'''

n = int(input())
mat = []
for i in range(n-1):
  mat.append(input())

# 1, 1
def getEdge(n, m):
  global mat
  return mat[n-1][m-2-(n-1)]

def DFS(s, n, color):
  global mat
  st = [s]

  # DFS
  while len(st) > 0:

    v = st.pop()
    # if white
    if color.get(v, 0) == 0:
      # color Grey
      color[v] = 1
      st.append(v)

      # print('ver', v)
      # go through edges
      for v2 in range(n):
        if v < v2:
          # to speedup
          #if getEdge(v, v2) == "R":
          if mat[v][v2-1-v] == "R":
            c = color.get(v2, 0)
            if c == 0:
              st.append(v2)
            elif c == 1: # we found a cycle
              return "NO"
        elif v2 < v:
          # to speedup
          #if getEdge(v2, v) == "B":
          if mat[v2][v-1-v2] == "B":
            c = color.get(v2, 0)
            if c == 0:
              st.append(v2)
            elif c == 1: # we found a cycle
              return "NO"
    # if grey
    elif color[v] == 1:
      # to black
      color[v] = 2

  return "YES"


def solution(n, mat):
  color = {}

  # go through vertexes
  for s in range(n):
    # print('== dfs',s)
    if color.get(s, 0)==0:
      # call DFS
      if DFS(s, n, color) == "NO":
        return "NO"

  return "YES"

print(solution(n, mat))